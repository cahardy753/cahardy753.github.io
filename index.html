<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calvin Heckaton 2024</title>
    <style>

    </style>
</head>
<body>
    <div id="invenA" style="position: absolute; bottom: 85%; left: 7%; transform: translateX(-50%); margin-bottom: -30px;">
        <image class="btnClaim" src="UIs/inven.png" style="width: 100px; height: auto;">
    </div>
    <div id="invenB" style="position: absolute; bottom: 85%; left: 15%; transform: translateX(-50%); margin-bottom: -30px;">
        <image class="btnClaim" src="UIs/inven.png" style="width: 100px; height: auto;">
    </div>
    <div id="invenC" style="position: absolute; bottom: 85%; left: 23%; transform: translateX(-50%); margin-bottom: -30px;">
        <image class="btnClaim" src="UIs/inven.png" style="width: 100px; height: auto;">
    </div>
    <div id="invenD" style="position: absolute; bottom: 85%; left: 31%; transform: translateX(-50%); margin-bottom: -30px;">
        <image class="btnClaim" src="UIs/inven.png" style="width: 100px; height: auto;">
    </div>
    <div id="leftB" style="position: absolute; bottom: 50%; left: 5%; transform: translateX(-50%); margin-bottom: -30px;">
        <input type = 'image' class="btnClaim" src="UIs/camLB.png" style="width: 70px; height: auto;">
    </div>
    <div id="rightB" style="position: absolute; bottom: 50%; left: 95%; transform: translateX(-50%); margin-bottom: -30px;">
        <input type = 'image' class="btnClaim" src="UIs/camRB.png" style="width: 70px; height: auto;">
    </div>
    <div id="inspect0" style="position: absolute; bottom: 40%; left: 75%; transform: translateX(-50%); margin-bottom: -30px;">
        <image class="btnClaim" src="UIs/mag.png" style="width: 50px; height: auto;">
    </div>
    <div id="inspect1" style="position: absolute; bottom: 42%; left: 17%; transform: translateX(-50%); margin-bottom: -30px;">
        <image class="btnClaim" src="UIs/mag.png" style="width: 50px; height: auto;">
    </div>
    <div id="temp" style="position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%); margin-bottom: -30px;">
        <image class="btnClaim" src="UIs/letter_acq.png" style="width: 700px; height: auto;">
    </div>
    <div id="closeB" style="position: absolute; bottom: 70%; left: 65%; transform: translateX(-50%); margin-bottom: -30px;">
        <input type = 'image' class="btnClaim" src="UIs/close.png" style="width: 70px; height: auto;">
    </div>
    <div id="letter" style="position: absolute; bottom: 87%; left: 7%; transform: translateX(-50%); margin-bottom: -30px;">
        <input type = 'image' class="btnClaim" src="UIs/letter.png" style="width: 55px; height: auto;">
    </div>
	
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
          }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

	let currentPos = 0;
        let interactObjs = [];
        let drawer, intersects;
        let drawerOpened, start = false;
	    
	//UI configs
        inspect0.style.display = 'none';
	inspect1.style.display = 'none';
        temp.style.display = 'none';
        closeB.style.display = 'none';
        letter.style.display = 'none';

        leftB.addEventListener('click', toggleCamL);
        rightB.addEventListener('click', toggleCamR);
        closeB.addEventListener('click', closeScr);
        letter.addEventListener('click', letterOpen);

	//scene & raycaster
        var raycaster = new THREE.Raycaster();
        var ptr = new THREE.Vector2();
        window.addEventListener( 'mousemove', onPtrMove );
        window.addEventListener( 'click', onClick );
	
        var scene = new THREE.Scene(); //create scene
        var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 ); //create camera
        camera.position.set(0, 1, 3); //0, 1, 2

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        const listener = new THREE.AudioListener();//create a listener and add it to camera
        camera.add( listener );

	    
	//Basic Backgrounds
        //Light
        var mainLight = new THREE.PointLight(0xffffff, 5);
        mainLight.position.set(0, 1.5, 3);
        scene.add(mainLight);

        //Floor
        var groundTexture = new THREE.TextureLoader().load( "textures/floor.jpg" );
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set( 1, 1 );
        groundTexture.anisotropy = 16;
        groundTexture.encoding = THREE.sRGBEncoding;

		var groundMaterial = new THREE.MeshStandardMaterial( { map: groundTexture } );

        var geometry = new THREE.PlaneGeometry( 6, 6 );
        var floor = new THREE.Mesh( geometry, groundMaterial );
        floor.rotation.x = - Math.PI / 2;
        floor.position.z = 3;
        scene.add( floor );

        //Ceiling
        var celingTexture = new THREE.TextureLoader().load( "textures/tempC.jpg" );
        celingTexture.wrapS = celingTexture.wrapT = THREE.RepeatWrapping;
        celingTexture.repeat.set( 1, 1 );
        celingTexture.anisotropy = 16;
        celingTexture.encoding = THREE.sRGBEncoding;

		var celingMaterial = new THREE.MeshStandardMaterial( { map: celingTexture, side: THREE.DoubleSide } );

        var mesh = new THREE.Mesh( new THREE.PlaneGeometry( 6, 6 ), celingMaterial );
		mesh.position.y = 2.5;
        mesh.position.z = 3;
		mesh.rotation.x = -Math.PI/2;
		mesh.receiveShadow = true;
		scene.add( mesh );

        //Front Wall
        var wallTexture = new THREE.TextureLoader().load( "textures/tempWall.jpg" );
        wallTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.repeat.set( 1, 1 );
        wallTexture.anisotropy = 16;
        wallTexture.encoding = THREE.sRGBEncoding;

		var wallMaterial = new THREE.MeshStandardMaterial( { map: wallTexture } );

        geometry = new THREE.PlaneGeometry( 6, 3 );
        var wallFront = new THREE.Mesh( geometry, wallMaterial );
        wallFront.position.y = 1;
        scene.add( wallFront );

        //Left Wall
        geometry = new THREE.PlaneGeometry( 6, 3 );
        var wallLeft = new THREE.Mesh( geometry, wallMaterial );
        wallLeft.position.y = 1;
        wallLeft.position.x = -3;
        wallLeft.position.z = 3;
        wallLeft.rotation.y = Math.PI / 2;
        scene.add( wallLeft );

        //Right Wall
        geometry = new THREE.PlaneGeometry( 6, 3 );
        var wallRight = new THREE.Mesh( geometry, wallMaterial );
        wallRight.position.y = 1;
        wallRight.position.x = 3;
        wallRight.position.z = 3;
        wallRight.rotation.y = - Math.PI / 2;
        scene.add( wallRight );

        //Back Wall
        geometry = new THREE.PlaneGeometry( 6, 3 );
        var wallBack = new THREE.Mesh( geometry, wallMaterial );
        wallBack.position.y = 1;
        wallBack.position.z = 6;
        wallBack.rotation.y = Math.PI;
        scene.add( wallBack );

	//dummy
        geometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
        var material = new THREE.MeshBasicMaterial( { color: 0xff0f00 } );
        const cube = new THREE.Mesh( geometry, material );
        cube.position.y = -100;
        scene.add( cube );

	//3D Models
	const loader = new GLTFLoader();
        //load small lamp
    loader.load('/models/smallLamp.glb', function (gltf) {
        let smallLamp = gltf.scene;
        smallLamp.scale.set(1,1,1);
        smallLamp.position.y = .675;
        smallLamp.position.x = 2;
        smallLamp.position.z = .75;
        scene.add(smallLamp);
        }, undefined, function ( error ) {
            console.error(error);
        } );
        //load chest drawers into scene
	loader.load( '/models/CHEST_OF_DRAWER.glb', function ( gltf ) {
        var drawer = gltf.scene;
        drawer.scale.set(.7,.7,.7);
        drawer.position.y = .21;
        drawer.position.x = .25;
        drawer.position.z = .55;
        drawer.rotation.y = (-Math.PI/2);
        scene.add(drawer);
	interactObjs.push(drawer);
        }, undefined, function ( error ) {
	        console.error( error );
        } );

        //load old bed into scene
    loader.load( '/models/oldBed.glb', function (gltf) {
        let oldBed = gltf.scene; //create object
        let oldBedModel = gltf.scene.children[0];
        let oldBedBody = oldBedModel.getObjectByName('body');

        oldBedModel.material = new THREE.MeshStandardMaterial( {color: 0xda8603, metalness: .4, roughness: 0.0, name: 'burnt orange'} );
        oldBed.scale.set(.8,.8,.9);
        oldBed.position.y = 0;
        oldBed.position.x = 0;
        oldBed.position.z = -.125;
        oldBed.rotation.y = (-Math.PI/2);
        scene.add(oldBed);
    	}, undefined, function ( error ) {
	        console.error( error );
    	})
	//goes from here
        
        document.addEventListener("keydown", onDocumentKeyDown, false); //For key binding

        function onDocumentKeyDown(event) {
            var keyCode = event.which;
            if (start) {    //only works when game start is true
                if (keyCode == 37) { //if leftArrow key is pressed, rotate the cam by -90`
                    camera.rotation.y += Math.PI / 2;
                    if (currentPos != 0) {
                        currentPos --;
                    } else {
                        currentPos = 3;
                    }
                } else if (keyCode == 39) { //if rightArrow key is pressed, rotate the cam by 90`
                    camera.rotation.y += -Math.PI / 2;
                    if (currentPos != 3) {
                        currentPos ++;
                    } else {
                        currentPos = 0;
                    }
                } else if (keyCode == 27) {
                    //Show settings screen
                }
            }
            if (keyCode == 32) {
                time.style.display = 'none';
                start = true;
            }
        };

	    function toggleCamL() {
            if (start) {
                camera.rotation.y += Math.PI / 2;
                if (currentPos != 0) {
                        currentPos --;
                    } else {
                        currentPos = 3;
                }
            }
        }

        function toggleCamR() {
            if (start) {
                camera.rotation.y += -Math.PI / 2;
                if (currentPos != 3) {
                        currentPos ++;
                    } else {
                        currentPos = 0;
                }
            } 
        }

	//raycaster fcns
        
        let playMusicFlag = false;

        function onPtrMove(event) {
            ptr.x = (event.clientX / window.innerWidth) * 2 - 1;
            ptr.y = -(event.clientY / window.innerHeight) * 2 + 1;
            intersects = raycaster.intersectObjects(interactObjs, true);
            raycaster.setFromCamera(ptr, camera);

            for (const intersect of intersects) {
                if (start) {
                    if (intersect.object === cube) {
                    return;
                } else {
                    if (currentPos == 0) {
                        inspect0.style.display = 'block';
                    } else if (currentPos == 1) {
                        inspect1.style.display = 'block';
                    }
                    return;
                    }
                }
            }

            //check for music flag
            if (playMusicFlag == false) {
                const sound = new THREE.Audio( listener );
            // load a sound and set it as the Audio object's buffer
                const audioLoader = new THREE.AudioLoader();
                audioLoader.load( 'Sounds/JohnnyGuitar.ogg', function( buffer ) {
                    sound.setBuffer( buffer );
                    sound.setLoop( true );
                    sound.setVolume( 0.5 );
                    sound.play();
                });
                playMusicFlag = true;
            }
            

            // Reset
            inspect0.style.display = 'none';
	    inspect1.style.display = 'none';
        }

        function onClick() {
            if (start) {
                for (const intersect of intersects) {
                    if (intersect.object === cube) {
                        return;
                    } else {
                        temp.style.display = 'block';
                        closeB.style.display = 'block';
                        drawerOpened = true;
                        pg.play();
                        return;
                    }
                }
            }
        }

        function closeScr() {
            temp.style.display = 'none';
            closeB.style.display = 'none';
        }

        function letterOpen(){ 
            temp.style.display = 'block';
            closeB.style.display = 'block';
        }

        function animation() {
            requestAnimationFrame( animation );

		if (drawerOpened) {
			letter.style.display = 'block';
		}
	        renderer.render( scene, camera );
        }

        animation();


    </script>

</body>
</html>
